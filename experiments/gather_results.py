"""Tools for collecting and analyzing results generated by ``sacred`` runs."""

from collections import OrderedDict
import imageio
import matplotlib.pyplot as plt
import numpy as np
import os
import simplejson as json
import warnings


def experiment_dirs(root_path):
    """Return the list of directories containing experiments."""
    contents = os.listdir(root_path)
    dirs = []
    for entry in contents:
        try:
            int(entry)
        except ValueError:
            pass
        else:
            dirs.append(entry)

    return tuple(dirs)


def get_run_info(path):
    """Load the run information from the ``run.json`` file into a dict."""
    filename = os.path.join(path, 'run.json')
    with open(filename, 'r') as fp:
        run_info = json.load(fp)

    return run_info


def get_run_config(path):
    """Read the run configuration from the ``config.json`` file into a dict."""
    filename = os.path.join(path, 'config.json')
    with open(filename, 'r') as fp:
        run_cfg = json.load(fp)

    return run_cfg


def get_foms(path, run_info=None):
    """Read the Figures of Merit resulting from an experiment."""
    if run_info is None:
        run_info = get_run_info(path)

    artifacts = run_info['artifacts']
    fom_files = [s for s in artifacts if s.endswith('fom.txt')]
    if len(fom_files) == 0:
        warnings.warn("no FOM text file ending with 'fom.txt' found in "
                      'directory {!r}'.format(path),
                      RuntimeWarning)
        return None

    elif len(fom_files) > 1:
        warnings.warn("multiple FOM text files found in directory {}, using "
                      '{!r}'.format(path, fom_files[0]),
                      RuntimeWarning)

    fom_fname = os.path.join(path, fom_files[0])
    with open(fom_fname, 'r') as fp:
        lines = fp.readlines()

    foms = {}
    for line in lines:
        try:
            name, val = line.split(':')
            val = float(val)
        except ValueError:
            warnings.warn('in file {!r}: ignoring invalid line\n'
                          '{!r}'.format(fom_fname, line))

        foms[name] = val

    return foms


def get_reco_image(path, run_info=None):
    """Load the reconstruction image of an experiment.

    Reconstruction images are recognized by their endings ``reco.png``
    or ``reco.jpg``. If no such image exists, ``None`` is returned.
    """
    if run_info is None:
        run_info = get_run_info(path)

    artifacts = run_info['artifacts']
    reco_image_files = [
        a for a in artifacts
        if a.endswith('reco.png') or a.endswith('reco.jpg')]

    if len(reco_image_files) == 0:
        return None
    elif len(reco_image_files) > 1:
        warnings.warn("multiple reco image files found in directory {}, using "
                      '{!r}'.format(path, reco_image_files[0]),
                      RuntimeWarning)

    reco_image_file = reco_image_files[0]
    return imageio.imread(reco_image_file)


def get_profile_image(path, run_info=None):
    """Load the reco profile image of an experiment.

    Reconstruction profile images are recognized by their endings
    ``profile.png`` or ``profile.jpg``. If no such image exists, ``None``
    is returned.
    """
    if run_info is None:
        run_info = get_run_info(path)

    artifacts = run_info['artifacts']
    profile_image_files = [
        a for a in artifacts
        if a.endswith('profile.png') or a.endswith('profile.jpg')]

    if len(profile_image_files) == 0:
        return None
    elif len(profile_image_files) > 1:
        warnings.warn("multiple profile image files found in directory {}, "
                      'using {!r}'.format(path, profile_image_files[0]),
                      RuntimeWarning)

    profile_image_file = profile_image_files[0]
    return imageio.imread(profile_image_file)


def get_reco_data(path, run_info=None):
    """Load the raw reconstruction data of an experiment.

    Reconstruction datasets are recognized by their endings ``reco.npy``
    or ``reco.npz``. If no such file exists, ``None`` is returned.
    """
    if run_info is None:
        run_info = get_run_info(path)

    artifacts = run_info['artifacts']
    reco_data_files = [
        a for a in artifacts
        if a.endswith('reco.npy') or a.endswith('reco.npz')]

    if len(reco_data_files) == 0:
        return None
    elif len(reco_data_files) > 1:
        warnings.warn("multiple reco data files found in directory {}, "
                      'using {!r}'.format(path, reco_data_files[0]),
                      RuntimeWarning)

    reco_data_file = reco_data_files[0]
    return np.load(reco_data_file, allow_pickle=False)


def collect_metadata(root_path):
    """Get metadata of all experiments, up to a possible filter."""
    dirs = experiment_dirs(root_path)
    metadata = {}
    for d in dirs:
        metadata[d] = {}
        metadata[d]['run_info'] = get_run_info(os.path.join(root_path, d))
        metadata[d]['run_config'] = get_run_config(os.path.join(root_path, d))
        metadata[d]['foms'] = get_foms(os.path.join(root_path, d),
                                       metadata[d]['run_info'])
        # Add stubs for other keys so we don't get KeyError
        metadata[d]['reco_image'] = None
        metadata[d]['profile_image'] = None
        metadata[d]['reco_data'] = None

    return metadata


def filter_info(metadata, func):
    """Filter entries in the ``'run_info'`` part of the metadata.

    The returned dictionary contains the entries in the original
    metadata for which ::

        func(metadata[d]['run_info']) is True

    where ``d`` is the directory containing the experiment (a string with
    a number). For instance, ::

        filter_config(metadata, lambda c: c['status'] == 'COMPLETED')

    will contain all entries where the experiment ran until completion.
    """
    return {key: entry for key, entry in metadata.items()
            if func(entry['run_info'])}


def filter_config(metadata, func):
    """Filter entries in the ``'run_config'`` part of the metadata.

    The returned dictionary contains the entries in the original
    metadata for which ::

        func(metadata[d]['run_config']) is True

    where ``d`` is the directory containing the experiment (a string with
    a number). For instance, ::

        filter_config(metadata, lambda c: c['seed'] == 123)

    will contain all entries where the seed was 123.

    .. note::
        If you query for parameters that not all experiments have, make
        sure that the lookup is safe, i.e., the filter is defined similar
        to the following::

            def filter_reg_param(c):
                reg_param = c.get('reg_param', None)
                if reg_param is None:
                    return False
                else:
                    return reg_param == 1e-2
    """
    return {key: entry for key, entry in metadata.items()
            if func(entry['run_config'])}


def filter_foms(metadata, func):
    """Filter entries in the ``'foms'`` part of the metadata.

    The returned dictionary contains the entries in the original
    metadata for which ::

        func(metadata[d]['foms']) is True

    where ``d`` is the directory containing the experiment (a string with
    a number). For instance, ::

        filter_foms(metadata, lambda c: c['PSNR'] > 20)

    will contain all entries where the experiment resulted in a PSNR of
    more than 20.
    """
    return {key: entry for key, entry in metadata.items()
            if func(entry['foms'])}


def sort_config(metadata, key):
    """Return an ordered dict of metadata sorted according to a key function.

    The returned ``OrderedDict`` is sorted in ascending order according to
    the criterion ::

        key(metadata[d1]['run_config']) <= key(metadata[d2]['run_config'])

        --> d1 <= d2

    where ``d1`` and ``d2`` are names of directories containing experiments
    (a string with a number). For instance, ::

        sort_config(metadata, lambda c: c['reg_param'])

    will sort the experiments according to their used regularization
    parameter, from lowest to highest.
    """
    return OrderedDict(
        (k, metadata[k])
        for k in sorted(metadata.keys(),
                        key=lambda f: key(metadata[f]['run_config'])))


def topk_foms(metadata, fom_name, k):
    """Return an ordered dict of the top k entries according to a given FOM.

    The returned ``OrderedDict`` contains ``k`` key-value pairs from
    ``metadata`` where ``entry['foms']['fom_name']`` is highest.
    """
    def fom_key(c):
        if c is None:
            return -1
        else:
            return c[fom_name]

    fom_sorted = sort_foms(metadata, key=fom_key)
    return OrderedDict((key, fom_sorted[key])
                       for key in list(reversed(fom_sorted.keys()))[:k])


def sort_foms(metadata, key):
    """Return an ordered dict of metadata sorted according to a key function.

    The returned ``OrderedDict`` is sorted in ascending order according to
    the criterion ::

        key(metadata[d1]['foms']) <= key(metadata[d2]['foms'])

        --> d1 <= d2

    where ``d1`` and ``d2`` are names of directories containing experiments
    (a string with a number). For instance, ::

        sort_foms(metadata, lambda c: c['PSNR'])

    will sort the experiments according to their resulting PSNR, from
    lowest to highest.
    """
    return OrderedDict(
        (k, metadata[k])
        for k in sorted(metadata.keys(),
                        key=lambda f: key(metadata[f]['foms'])))


def update_metadata_with_images(root_path, metadata):
    """Add the reconstruction images of each experiment.

    The images are placed under the keys ``'reco_image'`` and
    ``'profile_image'`` in each subdict.
    """
    for d, entry in metadata.items():
        path = os.path.join(root_path, d)
        reco_image = get_reco_image(path, entry['run_info'])
        if entry.get('reco_image', None) is not None:
            warnings.warn('in experiment {}: replacing old reco_image'
                          ''.format(d),
                          RuntimeWarning)
        entry['reco_image'] = reco_image
        profile_image = get_profile_image(path, entry['run_info'])
        if entry.get('profile_image', None) is not None:
            warnings.warn('in experiment {}: replacing old profile_image'
                          ''.format(d),
                          RuntimeWarning)
        entry['profile_image'] = profile_image


def update_metadata_with_data(root_path, metadata):
    """Add the raw reconstruction data of each experiment.

    The data is placed under the key ``'reco_data'`` in each subdict.
    """
    for d, entry in metadata.items():
        path = os.path.join(root_path, d)
        reco_data = get_reco_data(path, entry['run_info'])
        if entry.get('reco_data', None) is not None:
            warnings.warn('in experiment {}: replacing old reco_data'
                          ''.format(d),
                          RuntimeWarning)
        entry['reco_data'] = reco_data


def show_recos(metadata, plain=False, saveto_dir=None, **imshow_kwargs):
    """Make plots of all reconstruction data in the metadata.

    All datasets are assumed to be 2-dimensional and will be displayed
    as images.

    The provided ``metadata`` can be either a dictionary (unordered) or a
    tuple of ``(key, value)`` tuples (ordered). In the former case,
    the experiment ID is appended to the base experiment name to generate
    the image file name. In the latter case, the position of the experiment
    in the tuple is appended before the ID, such that the file names
    preserve this order.

    For ``plain=True``, the image will not be supplemented
    by axis labels, colorbars etc, which is the default behavior.

    If a string ``saveto_dir`` is given, the images will be saved there
    in PNG format.

    The ``imshow_kwargs`` are passed on to ``matplotlib.pyplot.imshow``.

    .. warning::
        For a large number of experiments, this can take very long time
        and clog the screen. To avoid that, use a subset of the experments
        by filtering.
    """
    use_pos = isinstance(metadata, OrderedDict)

    for pos, (d, entry) in enumerate(metadata.items()):
        data = entry.get('reco_data', None)
        if data is None:
            continue

        if data.ndim != 2:
            warnings.warn('in experiment {}: data has invalid dimension {},'
                          'expected `ndim == 2`'.format(d, data.ndim),
                          RuntimeWarning)
            continue

        fig, ax = plt.subplots()
        ax.imshow(data, **imshow_kwargs)

        if not plain:
            plt.title('Experiment ' + d)
            fig.colorbar(ax.images[0])

        if saveto_dir is not None:
            if use_pos:
                image_fname = os.path.join(
                    saveto_dir, d, 'reco_pos_{}_id_{}.png'.format(pos, d))
            else:
                image_fname = os.path.join(
                    saveto_dir, d, 'reco_id_{}.png'.format(d))

            fig.savefig(image_fname)


# %% Testing

root_path = '/home/hkohr/variable_lp_experiments/tgv'
metadata = collect_metadata(root_path)
par2d_meta = filter_config(metadata,
                           lambda c: c['geometry'] == 'parallel2d')
top3_ssim = topk_foms(par2d_meta, 'SSIM', 3)
for k, entry in top3_ssim.items():
    print('ID = {}, SSIM = {}, PSNR = {}'
          ''.format(k, entry['foms']['SSIM'], entry['foms']['PSNR']),
          entry['run_config'])
